package maker

import (
	"go/format"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestMaker(t *testing.T) {
	require := require.New(t)

	src := `package main

import "fmt"

type Human struct {
	name string
	age  int
}

// Returns the name of our Human.
func (h *Human) GetName() string {
	return h.name
}

// Our Human just had a birthday! Increase its age.
func (h *Human) Birthday() {
	h.age += 1
	fmt.Printf("I am now %d years old!\n", h.age)
}

// Make the Human say hello.
func (h *Human) SayHello() {
	fmt.Printf("Hello, my name is %s, and I am %d years old.\n", h.name, h.age)
}

func main() {
	human := &Human{name: "Bob", age: 30}
	human.GetName()
	human.SayHello()
	human.Birthday()
}
`
	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	"fmt"
)

type HumanIface interface {
	// Returns the name of our Human.
	GetName() string
	// Our Human just had a birthday! Increase its age.
	Birthday()
	// Make the Human say hello.
	SayHello()
}
`

	expectedImports := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

type HumanIface interface {
	// Returns the name of our Human.
	GetName() string
	// Our Human just had a birthday! Increase its age.
	Birthday()
	// Make the Human say hello.
	SayHello()
}
`

	maker := &Maker{
		StructName: "Human",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src), "human.go"))

	result := maker.makeInterface("interfaces", "HumanIface")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
	formattedImports, err := maker.MakeInterface("interfaces", "HumanIface")
	require.Nil(err)
	require.Equal(expectedImports, string(formattedImports))
}

func TestNoCopyDocs(t *testing.T) {
	require := require.New(t)

	src := `package main

import "fmt"

type Human struct {
	name string
	age  int
}

// Returns the name of our Human.
func (h *Human) GetName() string {
	return h.name
}

// Our Human just had a birthday! Increase its age.
func (h *Human) Birthday() {
	h.age += 1
	fmt.Printf("I am now %d years old!\n", h.age)
}

// Make the Human say hello.
func (h *Human) SayHello() {
	fmt.Printf("Hello, my name is %s, and I am %d years old.\n", h.name, h.age)
}

func main() {
	human := &Human{name: "Bob", age: 30}
	human.GetName()
	human.SayHello()
	human.Birthday()
}
`
	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	"fmt"
)

type HumanIface interface {
	GetName() string
	Birthday()
	SayHello()
}
`

	maker := &Maker{
		StructName: "Human",
		CopyDocs:   false,
	}

	require.Nil(maker.ParseSource([]byte(src), "human.go"))

	result := maker.makeInterface("interfaces", "HumanIface")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestTypes(t *testing.T) {
	require := require.New(t)

	src := `package main

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i int64) (string, error) {
	return bar + baz, nil
}
`
	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import ()

type IFoo interface {
	Foo(bar, baz string, i int64) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src), "foo.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestMultipleSources(t *testing.T) {
	require := require.New(t)

	src1 := `package main

type Foo struct {
}

// Foo is a test method.
// This comment is the same for both methods.
func (f Foo) Foo(bar, baz string, i int64) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

// Qux is a test method.
// This comment is the same for both methods.
func (f Foo) Qux(ok bool) (string, error) {
	return "ok", nil
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import ()

type IFoo interface {
	// Foo is a test method.
	// This comment is the same for both methods.
	Foo(bar, baz string, i int64) (string, error)
	// Qux is a test method.
	// This comment is the same for both methods.
	Qux(ok bool) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	require.Nil(maker.ParseSource([]byte(src2), "foo2.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))

}

func TestDifferentAliases(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg1 "github.com/user/pkg"
)

func (f Foo) Qux(ok bool, i pkg1.Foo) (string, error) {
	return "ok", nil
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	err := maker.ParseSource([]byte(src2), "foo2.go")
	require.NotNil(err)
	require.Equal("Package \"github.com/user/pkg\" imported multiple times with different aliases: pkg, pkg1", err.Error())
}

func TestConflictingAliases(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg "github.com/user/pkg2"
)

func (f Foo) Qux(ok bool, i pkg.Foo) (string, error) {
	return "ok", nil
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	err := maker.ParseSource([]byte(src2), "foo2.go")
	require.NotNil(err)
	require.Equal("Import alias pkg already in use", err.Error())
}

func TestAliasedUnaliased(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	"github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg "github.com/user/pkg"
)

func (f Foo) Qux(ok bool, i pkg.Foo) (string, error) {
	return "ok", nil
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	err := maker.ParseSource([]byte(src2), "foo2.go")
	require.NotNil(err)
	require.Equal("Package \"github.com/user/pkg\" imported multiple times with different aliases: <none>, pkg", err.Error())
}

func TestCorrectAliases(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg "github.com/user/pkg"
)

func (f Foo) Qux(ok bool, i pkg.Foo) (string, error) {
	return "ok", nil
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	pkg "github.com/user/pkg"
)

type IFoo interface {
	Foo(bar, baz string, i pkg.Foo) (string, error)
	Qux(ok bool, i pkg.Foo) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	require.Nil(maker.ParseSource([]byte(src2), "foo2.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestMultipleUnaliased(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	"github.com/user/pkg"
	"github.com/user/pkg1"
)

type Foo struct {
}

func (f Foo) Foo(a pkg.PkgType, b pkg.Pkg1Type) error {
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	"github.com/user/pkg"
	"github.com/user/pkg1"
)

type IFoo interface {
	Foo(a pkg.PkgType, b pkg.Pkg1Type) error
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestDotImportsAndUnexported(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	. "github.com/user/otherpkg"
)

func (f Foo) qux(ok bool, i DotImported) (string, error) {
	return "ok", nil
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	pkg "github.com/user/pkg"
)

type IFoo interface {
	Foo(bar, baz string, i pkg.Foo) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	require.Nil(maker.ParseSource([]byte(src2), "foo2.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}
