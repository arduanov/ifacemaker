package maker

import (
	"bytes"
	"go/format"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestMaker(t *testing.T) {
	require := require.New(t)

	src := `package main

import "fmt"

type Human struct {
	name string
	age  int
}

// Returns the name of our Human.
func (h *Human) GetName() string {
	return h.name
}

// Our Human just had a birthday! Increase its age.
func (h *Human) Birthday() {
	h.age += 1
	fmt.Printf("I am now %d years old!\n", h.age)
}

// Make the Human say hello.
func (h *Human) SayHello() {
	fmt.Printf("Hello, my name is %s, and I am %d years old.\n", h.name, h.age)
}

func main() {
	human := &Human{name: "Bob", age: 30}
	human.GetName()
	human.SayHello()
	human.Birthday()
}
`
	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	"fmt"
)

type HumanIface interface {
	// Returns the name of our Human.
	GetName() string
	// Our Human just had a birthday! Increase its age.
	Birthday()
	// Make the Human say hello.
	SayHello()
}
`

	expectedImports := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

type HumanIface interface {
	// Returns the name of our Human.
	GetName() string
	// Our Human just had a birthday! Increase its age.
	Birthday()
	// Make the Human say hello.
	SayHello()
}
`

	maker := &Maker{
		StructName: "Human",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src), "human.go"))

	result := maker.makeInterface("interfaces", "HumanIface")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
	formattedImports, err := maker.MakeInterface("interfaces", "HumanIface")
	require.Nil(err)
	require.Equal(expectedImports, string(formattedImports))
}

func TestNoCopyDocs(t *testing.T) {
	require := require.New(t)

	src := `package main

import "fmt"

type Human struct {
	name string
	age  int
}

// Returns the name of our Human.
func (h *Human) GetName() string {
	return h.name
}

// Our Human just had a birthday! Increase its age.
func (h *Human) Birthday() {
	h.age += 1
	fmt.Printf("I am now %d years old!\n", h.age)
}

// Make the Human say hello.
func (h *Human) SayHello() {
	fmt.Printf("Hello, my name is %s, and I am %d years old.\n", h.name, h.age)
}

func main() {
	human := &Human{name: "Bob", age: 30}
	human.GetName()
	human.SayHello()
	human.Birthday()
}
`
	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	"fmt"
)

type HumanIface interface {
	GetName() string
	Birthday()
	SayHello()
}
`

	maker := &Maker{
		StructName: "Human",
		CopyDocs:   false,
	}

	require.Nil(maker.ParseSource([]byte(src), "human.go"))

	result := maker.makeInterface("interfaces", "HumanIface")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestTypes(t *testing.T) {
	require := require.New(t)

	src := `package main

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i int64) (string, error) {
	return bar + baz, nil
}
`
	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import ()

type IFoo interface {
	Foo(bar, baz string, i int64) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src), "foo.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestMultipleSources(t *testing.T) {
	require := require.New(t)

	src1 := `package main

type Foo struct {
}

// Foo is a test method.
// This comment is the same for both methods.
func (f Foo) Foo(bar, baz string, i int64) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

// Qux is a test method.
// This comment is the same for both methods.
func (f Foo) Qux(ok bool) (string, error) {
	return "ok", nil
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import ()

type IFoo interface {
	// Foo is a test method.
	// This comment is the same for both methods.
	Foo(bar, baz string, i int64) (string, error)
	// Qux is a test method.
	// This comment is the same for both methods.
	Qux(ok bool) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	require.Nil(maker.ParseSource([]byte(src2), "foo2.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))

}

func TestDifferentAliases(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg1 "github.com/user/pkg"
)

func (f Foo) Qux(ok bool, i pkg1.Foo) (string, error) {
	return "ok", nil
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	err := maker.ParseSource([]byte(src2), "foo2.go")
	require.NotNil(err)
	require.Equal("package \"github.com/user/pkg\" imported multiple times with different aliases: pkg, pkg1", err.Error())
}

func TestConflictingAliases(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg "github.com/user/pkg2"
)

func (f Foo) Qux(ok bool, i pkg.Foo) (string, error) {
	return "ok", nil
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	err := maker.ParseSource([]byte(src2), "foo2.go")
	require.NotNil(err)
	require.Equal("import alias pkg already in use", err.Error())
}

func TestAliasedUnaliased(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	"github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg "github.com/user/pkg"
)

func (f Foo) Qux(ok bool, i pkg.Foo) (string, error) {
	return "ok", nil
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	err := maker.ParseSource([]byte(src2), "foo2.go")
	require.NotNil(err)
	require.Equal("package \"github.com/user/pkg\" imported multiple times with different aliases: <none>, pkg", err.Error())
}

func TestCorrectAliases(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	pkg "github.com/user/pkg"
)

func (f Foo) Qux(ok bool, i pkg.Foo) (string, error) {
	return "ok", nil
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	pkg "github.com/user/pkg"
)

type IFoo interface {
	Foo(bar, baz string, i pkg.Foo) (string, error)
	Qux(ok bool, i pkg.Foo) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	require.Nil(maker.ParseSource([]byte(src2), "foo2.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestMultipleUnaliased(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	"github.com/user/pkg"
	"github.com/user/pkg1"
)

type Foo struct {
}

func (f Foo) Foo(a pkg.PkgType, b pkg.Pkg1Type) error {
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	"github.com/user/pkg"
	"github.com/user/pkg1"
)

type IFoo interface {
	Foo(a pkg.PkgType, b pkg.Pkg1Type) error
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestDotImportsAndUnexported(t *testing.T) {
	require := require.New(t)

	src1 := `package main

import (
	pkg "github.com/user/pkg"
)

type Foo struct {
}

func (f Foo) Foo(bar, baz string, i pkg.Foo) (string, error) {
	return bar + baz, nil
}
`
	src2 := `package main

import (
	. "github.com/user/otherpkg"
)

func (f Foo) qux(ok bool, i DotImported) (string, error) {
	return "ok", nil
}
`

	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	pkg "github.com/user/pkg"
)

type IFoo interface {
	Foo(bar, baz string, i pkg.Foo) (string, error)
}
`

	maker := &Maker{
		StructName: "Foo",
		CopyDocs:   true,
	}

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))
	require.Nil(maker.ParseSource([]byte(src2), "foo2.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestTargetPackagePrefixing(t *testing.T) {
	require := require.New(t)

	src1 := `package nats

import "strings"

func (nc *Conn) Subscribe(subj string, cb MsgHandler) (*Subscription, error) {
	return nc.subscribe(subj, _EMPTY_, cb, nil)
}
func (nc *Conn) ChanQueueSubscribe(subj, group string, ch chan *Msg) (*Subscription, error) {
	return nc.subscribe(subj, group, nil, ch)
}
func (nc *Conn) TestChanArg(subj, group string, ch <-chan *Msg) (*Subscription, error) {
	return nc.subscribe(subj, group, nil, ch)
}
`
	expected := `// Code generated by ifacemaker. DO NOT EDIT.

package interfaces

import (
	"github.com/nats-io/nats"
	"strings"
)

var _ IFoo = (*nats.Conn)(nil)

type IFoo interface {
	Subscribe(subj string, cb nats.MsgHandler) (*nats.Subscription, error)
	ChanQueueSubscribe(subj, group string, ch chan *nats.Msg) (*nats.Subscription, error)
	TestChanArg(subj, group string, ch <-chan *nats.Msg) (*nats.Subscription, error)
}
`
	_ = expected
	maker := &Maker{
		StructName: "Conn",
		CopyDocs:   true,
		srcPackage: "nats",
	}
	maker.AddImport("", "github.com/nats-io/nats")

	require.Nil(maker.ParseSource([]byte(src1), "foo1.go"))

	result := maker.makeInterface("interfaces", "IFoo")
	formatted, err := format.Source([]byte(result))
	require.Nil(err)
	require.Equal(expected, string(formatted))
}

func TestReplaceType(t *testing.T) {
	require := require.New(t)

	m := &Maker{srcPackage: "foo"}

	rig := func(in string) string {
		buffer := bytes.NewBufferString(in)
		return m.replaceType(buffer).String()
	}

	// already qualified
	require.Equal("*other.Msg", rig("*other.Msg"))

	require.Equal("*foo.BarType", rig("*BarType"))
	require.Equal("foo.BarType", rig("BarType"))

	require.Equal("chan *foo.Msg", rig("chan *Msg"))
	require.Equal("<-chan *foo.Msg", rig("<-chan *Msg"))
	require.Equal("chan<- *foo.Msg", rig("chan<- *Msg"))

	require.Equal("func(*foo.List, bool) bool", rig("func(*List, bool) bool"))
	require.Equal("func(bool, *foo.List) bool", rig("func(bool, *List) bool"))
	require.Equal("func(bool, *foo.List_It) bool", rig("func(bool, *List_It) bool"))

	require.Equal("func(bool, *foo.List) *foo.Bar", rig("func(bool, *List) *Bar"))

}
